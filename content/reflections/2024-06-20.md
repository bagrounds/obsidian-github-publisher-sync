---  
share: true  
aliases:  
  - 2024-06-20  
title: 2024-06-20  
URL: https://bagrounds.org/reflections/2024-06-20  
Author: "[[bryan-grounds]]"  
tags:   
---  
[Home](../index.md) > [Reflections](./index.md) | [‚èÆÔ∏è](./2024-06-19.md)  
# 2024-06-20  
## üèÉ Running  
ü•µ Hot. Torturous. Today's run was the hardest I've endured in some time, though it was my standard route.  
üå°Ô∏è I guess temperature makes a big difference. Today's high is 79 degrees Fahrenheit.  
ü§∑ That probably means I'm spoiled with cool weather. Oh well.  
  
## [7.¬†Reverse Integer](https://leetcode.com/problems/reverse-integer)  
I previously did some isolated [planning](reflections/2024-06-13.md#7.%20Reverse%20Integer)(./2024-06-13.md##%5B7.%2520Reverse%2520Integer%5D(https%2520//leetcode.com/problems/reverse-integer)) for this problem.  
Let's see how well that planning helps with implementation today.  
  
#### ü™û Reflections  
1. Reading my previous planning notes & writing out a concrete plan took < 6 minutes  
2. My plan worked  
3. If I subtract the previous 11:44 from total time, this took 28:06  
    1. It's a medium problem, so that's probably acceptable, as I don't think I'll get 2 mediums in a single interview  
4. I'm happy that my plan worked out as expected  
5. I don't care too much about the 1 error that was caught at execution time. I don't think an interviewer will care about the parens needed for a negative next to an exponent.  
    1. Then again, I guess it is mathematically ambiguous without parens, because `(-x)^y` does not necessarily equal `-(x^y)`  
6. I used, perhaps more caution than was warranted by creating similar constants for, e.g. the number of digits in the extreme value  
    1. This caution was due to not knowing the exact value of the numbers and not wanting to hastily make a potentially invalid assumption  
    2. But it did make the code a bit more complex  
    3. I'd like to come back and clean the problem up to remove unnecessary complexity  
  
#### ‚å®Ô∏è My Solution  
```ts  
/*  
1. Reversing the digits is easy: toString -> toArray -> Reverse -> join -> parseInt  
2. The trick, however, is in the constraint that we can't store a number that's out of range.  
3. So we'll have to be able to identify when a number would be out of the 32 bit signed range before converting the string of digits back to a number.  
4. Alternatively, they might want us to detect overflow (i.e. we attempt to store a number bigger than can fit in 32 bits and the result is simply the wrong 32 bit number).  
5. If we simply had to detect overflow, we could just convert the reversed number back to a string after parsing the integer and check if it's the same string as before parsing.  
6. If we have to proactively decide if the (reversed) number will be too large before converting it to an integer, we can try several approaches  
    1. How many digits is the biggest (or smallest if negative) number we can fit in 32 bits? If our string is fewer digits, we're fine.  
    2. If our string has the max number of digits we can fit in 32 bits, we can check digit-by digit, from largest to smallest: if our reversed number's ith digit is smaller or equal to the max (min) able to fit in that place, we're fine. As soon as we find a digit that is strictly smaller, the remaining digits don't matter.  
  
There are log10 digits in a base-10 integer, and the amount of work we're doing is proportional to the number of digits, so:  
Runtime complexity: O(log(N)) in the passed in integer.  
Storing the digits will take O(log(N)) space.  
If the first approach is acceptable (I think we'd have to simulate this overflow effect in JavaScript), this implementation seems pretty easy.  
Implementing the second approach is quite doable, but could get a bit messy in tracking all of the details.  
  
**Planning Time: 11:44**  
  
Concretely:  
1. store min & max values as strings  
2. convert x to a string  
3. if length(x) < length(min|max) return the reversed number, else  
4. if length(x) > length(min|max) return 0  
5. if length(x) = length(min|max), check digit-by-digit, starting with greatest value  
[17:00] Done planning  
[28:24] Done with initial implementation  
[35:46] Done with first test  
[38:55] Done with 2nd test  
Errors found after manual testing:  
1. cannot put a negative to the left side of an exponentiation  
[39:50] Successful submission  
*/  
function reverse(x: number): number { // 7463847412; 2147483647  
  const MIN = -(2**31) // -2147483648 (I calculated this in a REPL, not by hand)  
  const MIN_STRING = MIN.toString().replace('-', '')  
  const MIN_DIGITS = MIN_STRING.length // 10  
  const MAX = 2**31 - 1 // 2147483647  
  const MAX_STRING = MAX.toString()  
  const MAX_DIGITS = MAX_STRING.length // 10  
  
  const isNegative = x < 0 // F; F  
  
  const extreme = isNegative ? MIN : MAX // 2147483647; 2147483647  
  const extremeString = isNegative ? MIN_STRING : MAX_STRING  
  const extremeDigits = isNegative ? MIN_DIGITS : MAX_DIGITS // 10  
  
  const digits = x.toString().replace('-', '') // '7463847412'; '2147483647'  
  const numDigits = digits.length // 10  
  const reversedDigits = digits.split('').reverse().join('') // '2147483647'; '7463847412'  
  
  const reverse = (): number =>  
    parseInt((isNegative ? '-' : '') + reversedDigits) // 2147483647; 7463847412  
  
  if (numDigits < extremeDigits) {  
    return reverse()  
  } else if (numDigits > extremeDigits) {  
    return 0  
  } else {  
    for (let i = 0; i < numDigits; i++) {  
      // 7 > 2 = true  
      if (parseInt(reversedDigits[i]) > parseInt(extremeString[i])) return 0 // return 0  
      if (parseInt(reversedDigits[i]) < parseInt(extremeString[i])) return reverse()  
      // 7 = 7; ...; 2 = 2  
      // if equal, check the next digit  
    }  
    // if all digits are equal, our reversed string is exactly the max value we can fit, so  
    // we can return the reversed number  
    return reverse() // 2147483647  
  }  
};  
```  
