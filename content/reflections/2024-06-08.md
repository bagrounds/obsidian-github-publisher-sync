---
share: true
aliases:
  - 2024-06-08 | ðŸ¦µðŸ¼ Shin ðŸ˜– Splints | ðŸ§® Number To Words ðŸ“ºâŒ¨ï¸
title: 2024-06-08 | ðŸ¦µðŸ¼ Shin ðŸ˜– Splints | ðŸ§® Number To Words ðŸ“ºâŒ¨ï¸
URL: https://bagrounds.org/reflections/2024-06-08
Author: "[[bryan-grounds]]"
tags:
  - code
---
[Home](../index.md) > [Reflections](./index.md) | [â®ï¸](./2024-06-07.md) [â­ï¸](./2024-06-09.md)  
# 2024-06-08 | ðŸ¦µðŸ¼ Shin ðŸ˜– Splints | ðŸ§® Number To Words ðŸ“ºâŒ¨ï¸  
## ðŸ§  Education  
- [ðŸƒðŸ¦µðŸ¤• SHIN SPLINTS for Runners: Challenges, Causes, and Rehab](../videos/shin-splints-for-runners-challenges-causes-and-rehab.md)  
- [ðŸ¦´ðŸ¤•ðŸƒâ€â™€ï¸ðŸ§ª How to Reduce Bone Injury Risks | Running Science](../videos/how-to-reduce-bone-injury-risks-running-science.md)  
  
## ðŸ‹ï¸ Revisiting numberToWords  
âœ¨ While planning my solution to `numberToWords` [yesterday](./2024-06-07.md#The%20(Revised)%20Solution), ðŸ’­ I mentioned that there was a ðŸ”„ recursive feel to the problem.  
ðŸ” However, I implemented an iterative solution.  
ðŸ›¡ï¸ In practice, iterative solutions are safer and ðŸš€ tend to be more performant.  
ðŸŽ¨ But recursive solutions can be more elegant, intelligible, and âœï¸ easier to write.  
ðŸ“š This is partly because recursion allows us to leverage the implicit function call stack provided by the language runtime.  
ðŸ§  If we're skilled at identifying recursive problems and implementing recursive solutions, we can save ourselves the time, effort, and complexity of implementing the stack that the corresponding iterative solution will require.  
  
ðŸ‘‡ Here's my recursive solution.  
  
```ts  
const UNDER20_WORDS = [  
  'Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six',  'Seven', 'Eight', 'Nine', 'Ten',  
  'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'  
]  
const DECADE__WORDS = [,, 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']  
  
const nonZeroNumberToWords = (n: number): string[] => n ? [numberToWords(n)] : []  
  
const numberToWords = (n: number): string =>  
    n < 2e1  
  ? UNDER_20_WORDS[n]  
  : n < 1e2  
  ? [DECADE__WORDS[Math.floor(n / 1e1)], ...nonZeroNumberToWords(n % 1e1)].join(' ')  
  : n < 1e3  
  ? [numberToWords(Math.floor(n / 1e2)), 'Hundred', ...nonZeroNumberToWords(n % 1e2)].join(' ')  
  : n < 1e6  
  ? [numberToWords(Math.floor(n / 1e3)), 'Thousand', ...nonZeroNumberToWords(n % 1e3)].join(' ')  
  : n < 1e9  
  ? [numberToWords(Math.floor(n / 1e6)), 'Million', ...nonZeroNumberToWords(n % 1e6)].join(' ')  
  : [numberToWords(Math.floor(n / 1e9)), 'Billion', ...nonZeroNumberToWords(n % 1e9)].join(' ')  
```  
  
ðŸ§ If we squint at the ðŸ”„ recursive implementation, we may notice some ðŸ‘¯â€â™€ï¸ repetition.  
ðŸ’¡ We can leverage the common pattern to derive a more âš™ï¸ data-driven implementation.  
âœ¨ This version highlights the ðŸ¤ sparsity of unique logic required.  
ðŸ§® A couple of ðŸ” lookup tables, some ðŸš¦ threshold comparisons, âž— division, ðŸ§µ string concatenation, and ðŸ”„ recursion are all we need to convert ðŸ”¢ numbers to ðŸ—£ï¸ English words. ðŸ˜… I probably wouldn't go this far in an interview, though. ðŸ˜¬  
  
  
```ts  
const UNDER20_WORDS = [  
  'Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six',  'Seven', 'Eight', 'Nine', 'Ten',  
  'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'  
]  
const DECADE__WORDS = [,, 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']  
const PATTERN = {  
  2e1: { divisor: 1e0, lookup: n => UNDER20_WORDS[n], suffix: [] },  
  1e2: { divisor: 1e1, lookup: n => DECADE__WORDS[n], suffix: [] },  
  1e3: { divisor: 1e2, lookup: n => numberToWords(n), suffix: ['Hundred'] },  
  1e6: { divisor: 1e3, lookup: n => numberToWords(n), suffix: ['Thousand'] },  
  1e9: { divisor: 1e6, lookup: n => numberToWords(n), suffix: ['Million'] },  
  5e9: { divisor: 1e9, lookup: n => numberToWords(n), suffix: ['Billion'] },  
}  
const THRESHOLDS = Object.keys(PATTERN)  
  
const nonZero = (num: number): string[] => num ? [numberToWords(num)] : []  
  
function numberToWords(n: number): string {  
  const { suffix, lookup, divisor } = PATTERN[THRESHOLDS.find(threshold => n < +threshold)]  
  return [lookup(Math.floor(n / divisor)), ...suffix, ...nonZero(n % divisor)].join(' ')  
}  
```