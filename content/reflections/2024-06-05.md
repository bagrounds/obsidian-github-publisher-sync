---  
share: true  
aliases:  
  - 2024-06-05  
title: 2024-06-05  
URL: https://bagrounds.org/reflections/2024-06-05  
Author: "[[bryan-grounds]]"  
tags:   
---  
[Home](../index.md) > [Reflections](./index.md) | [‚èÆÔ∏è](./2024-06-04.md)  
# 2024-06-05  
## ü™û Practice Reflections  
Yesterday, I observed a problem with my programming problem solving strategy.  
This prompted the question: [ü§î How can I generate higher quality algorithms without relying on testing?](./2024-06-04.md#ü§î%20How%20can%20I%20generate%20higher%20quality%20algorithms%20without%20relying%20on%20testing?)  
  
### üß†‚õàÔ∏è Brain Storming  
#### 1. Become familiar with more solutions  
1. Maybe this is a signal that the current bottleneck in my coding interview performance isn't coding.  
2. At least while practicing, when planning a solution to a problem, if I can't identify an algorithmic approach I'm confident in, it may be more fruitful to stop and do some research than to continue down a likely dead end path.  
  
#### 2. Develop a systematic approach to generating ideas  
When stuck in the planning phase, maybe I start asking myself a series of questions that may highlight an approach I'm familiar with, but that is currently not front of mind. Examples:  
1. What would a brute force approach look like? Typically, this involves generating every possible solution, testing each one, and returning a successful candidate.  
2. Is there a natural recursive solution? What is the base case? What do the sub problems look like?  
3. Is there a simpler version of this problem that I know how to solve? Sometimes a solution to a simpler problem can be modified to solve a more complicated problem.  
4. Is there a preprocessing step that would make this easier to solve? For example, sometimes sorting the input enables a tractable solution.  
5. Can I break the problem down into sub problems whos solutions can be combined to form a solution to the problem at hand?  
6. Is there a data structure that would make this problem easier to solve? Arrays, lists, stacks, queues, trees, graphs, tries, maps...  
  
#### 3. Practice writing algorithmic solutions in a shorthand pseudo code  
1. I'm kind of just winging it in the planning phase when it comes to writing out an algorithmic approach.  
2. It's easy to have a fuzzy idea in mind, but writing that idea out explicitly forces a degree of clarity. It extends frees up cognitive resources to focus on the sticking points.  
3. Having a systematic and familiar approach to writing down a solution can save a lot of time and help structure our thoughts in a way that aids analysis and elaboration.  
4. Of course, to be useful, this short-hand pseudo code would need to be much faster to write than a real programming language.  
5. What kinds of primitives would empower such an algorithmic pseudo code to be expressive, flexible, and precise enough to formulate a solution to any programming problem?  
6. Does this already exist? Can I copy someone else's approach rather than invent my own?  
7. Perhaps I can practice writing in such a language backward: by translating real solutions into this higher level pseudo code. This certainly seems like a good way to test the language for practicality. How much shorter is the pseudo code than the real solution? How much faster is it to write? What details can be omitted completely while maintaining a useful representation of the algorithm?  
  
#### 4. Practice programming planning solutions to programming problems without actually implementing or testing them.  
1. If I'm already pretty good at translating plans to code, I could save a lot of time and quickly develop a sense for how many and what kinds of problems I'm not prepared to solve.  
2. This could inform a study plan: ah, of a dozen LeetCode problems I wrote out plans for today, I couldn't confidently identify solutions to those involving e.g. binary search or tree traversal, etc  
