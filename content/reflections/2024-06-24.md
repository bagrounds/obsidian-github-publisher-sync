---  
share: true  
aliases:  
  - 2024-06-24  
title: 2024-06-24  
URL: https://bagrounds.org/reflections/2024-06-24  
Author: "[[bryan-grounds]]"  
tags:   
---  
[Home](../index.md) > [Reflections](./index.md) | [⏮️](./2024-06-23.md)  
# 2024-06-24  
## 🏋️ Coding Practice  
### [199. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view)  
> Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return _the values of the nodes you can see ordered from top to bottom_.  
  
#### 🪞 Reflections  
1. This is a very similar problem to what I saw in a real interview about a week ago  
2. that previous exposure seems to have been enough for a flawless performance today  
3. < 21 minutes isn't bad for a medium problem  
4. manually testing recursive functions is still a bit cumbersome  
5. representing trees in manual tests is still a bit cumbersome  
6. running 2 manual tests seemed like a good strategy here  
    1. the first was for good coverage of a tricky case (a tree where the rightmost node was sometimes in a left branch  
    2. the second was a simple null test, covering a common edge case  
7. having a 3rd check, explicitly for null checks didn't take much time and seems valuable to incorporate into my general strategy  
    1. This pass reminds me of static analysis: it takes less time to do than a dynamic test, we pay attention to fewer things, it's good for catching limited classes of bugs  
    2. I wonder if there are other classes of manual "static analysis" that would be useful to incorporate  
    3. Perhaps a manual type checking phase could be useful, where I ensure that I'm using values according to their types. This seems like good motivation to add more explicit type annotations to my code.  
8. While I forgot to annotate the time required for planning, it didn't take long. Seems like a good balance of succinct yet thorough enough to get the main ideas in place (though I didn't explicitly call out recursion in my plan... perhaps because I was already anticipating using this based on prior exposure to a very similar problem) and support proper big-O complexity analysis.  
  
#### ⌨️ My Solutions  
```ts  
/* return the nodes of a binary tree visible from the right  
1. we want to return the right-most element of each level of the tree  
  
Plan:  
1. convert the tree to levels  
2. get the rightmost element of each level  
  
time complexity: O(N) in the number of nodes in the tree  
extra space complexity: O(N) to store each level and the result  
[9:25] done with initial implementation  
[17:11] done with first test  
[19:11] done with 2nd test  
[20:45] done with null checks  
no bugs found during manual testing  
[20:56] successful submission  
no bugs found after manual testing  
*/  
/**  
 * Definition for a binary tree node.  
 * class TreeNode {  
 *     val: number  
 *     left: TreeNode | null  
 *     right: TreeNode | null  
 *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {  
 *         this.val = (val===undefined ? 0 : val)  
 *         this.left = (left===undefined ? null : left)  
 *         this.right = (right===undefined ? null : right)  
 *     }  
 * }  
 */  
function treeToLevels(root: TreeNode | null, depth = 0, levels: TreeNode[][] = []): TreeNode[][] { // null 0 []; {v:4} 1 [...]; {v:3} 2 [[1],[2]]; {v:2,r:{v:3}} 1 [1]; {v:1,l:{v:2,r:{v:3}},r:{v:4}} 0 []  
  if (root) { // null check  
    levels[depth] = (levels[depth] || []).concat(root) // [[1],[2,4],[3]] // null check  
    if (root.left) { // null check  
      treeToLevels(root.left, depth + 1, levels) // [[1]]  
    }  
    if (root.right) { // null check  
      treeToLevels(root.right, depth + 1, levels) //  
    }  
  }  
  return levels // []; [[1],[2,4],[3]]  
}  
  
function rightSideView(root: TreeNode | null): number[] { // null; {v:1,l:{v:2,r:{v:3}},r:{v:4}}  
  const levels = treeToLevels(root) // []; [[1],[2,4],[3]]  
  const rightMostNodes = levels.map(level => level[level.length - 1]) // []; [1,4,3] // we won't ever have nulls in this array  
  const rightMostValues = rightMostNodes.map(node => node.val) // []; [1,4,3] // we won't ever have nulls in this array  
  return rightMostValues // []; [1,4,3]  
};  
```  
