---  
share: true  
aliases:  
  - 2024-06-01  
title: 2024-06-01  
URL: https://bagrounds.org/reflections/2024-06-01  
Author: "[[bryan-grounds]]"  
tags:   
---  
[Home](../index.md) > [Reflections](./index.md) | [⏮️](./2024-05-31.md)  
# 2024-06-01  
## 🔍 Research  
- https://forum.obsidian.md/t/quickadd-template-filename-to-fetch-date-from-active-file/53656/4  
## 🧠 Education  
💡 [What Makes Some Brains More Focused Than Others? | Marvin Chun | TEDxKFAS](../videos/what-makes-some-brains-more-focused-than-others-marvin-chun-tedxkfas.md)  
  
## 🏋🏻 Practice  
  
[Merge 2 sorted lists](https://leetcode.com/problems/merge-two-sorted-lists/)  
> You are given the heads of two sorted linked lists `list1` and `list2`.  
>  
> Merge the two lists into one **sorted** list. The list should be made by splicing together the nodes of the first two lists.  
>  
> Return _the head of the merged linked list_.  
  
```ts  
/**  
 * Definition for singly-linked list.  
 * class ListNode {  
 *     val: number  
 *     next: ListNode | null  
 *     constructor(val?: number, next?: ListNode | null) {  
 *         this.val = (val===undefined ? 0 : val)  
 *         this.next = (next===undefined ? null : next)  
 *     }  
 * }  
 */  
/*  
Notes:  
- lists are sorted in ascending order  
- be careful managing cursors and pointers since we're mutating the input  
  
Plan:  
1. Initialize empty return value  
2. Set up 3 cursors, initialized to the head of each list, one for traversing the result  
3. Loop as long as at least one of the cursors is not null  
  a1. check that our cursors aren't null  
  a2. If we don't have a return value yet, set it to the smaller of the two & increment that cursor  
  b. choose which element is <= the other as the next item in our result  
  c. set the next pointer in our result cursor to this node  
4. return the result head  
  
Run-time complexity: O(N) - N = size of both input lists; O(N + M)  
Space complexity: O(1) extra space  
  
Test cases  
1. [], []  
2. [1], []  
3. [1, 2], [1]  
*/  
function mergeTwoLists1(list1: ListNode | null, list2: ListNode | null): ListNode | null {  
  let result: ListNode | null  
  // 1. null  
  // 2. 1 -> null  
  // 3. 1 -> 2 -> null  
  let c1: ListNode | null = list1  
  // 1. null  
  // 2. null  
  // 3. 1 -> null  
  let c2: ListNode | null = list2  
  let cr: ListNode | null  
  if (!c1 && !c2) {  
    // 1. null  
    result = null  
  } else if (!c1) {  
    result = c2  
    c2 = c2.next  
  } else if (!c2) {  
    // 2. 1 -> null  
    result = c1  
    // 2. null  
    c1 = c1.next  
  } else {  
    if (c1.val <= c2.val) {  
      // 3. 1 -> 2 -> null  
      result = c1  
      // 3. 2 -> null  
      c1 = c1.next  
    } else {  
      result = c2  
      c2 = c2.next  
    }  
  }  
  // 1. null  
  // 2. null  
  // 3. 1 -> 2 -> null  
  cr = result  
  for (; c1 || c2;) {  
    if (!c1) {  
      cr.next = c2  
      c2 = c2.next  
    } else if (!c2) {  
      // 3.2 cr = 1 -> 2 -> null  
      // 3.2 result = 1 -> 1 -> 2 -> null  
      cr.next = c1  
      // 3.2 c1 = null  
      c1 = c1.next  
    } else if (c1.val <= c2.val) {  
      cr.next = c1  
      c1 = c1.next  
    } else {  
      // 3.1 cr = 1 -> 1 -> null  
      cr.next = c2  
      // 3.1 null  
      c2 = c2.next  
    }  
    // 3.1 cr = 1 -> null  
    // 3.2 cr = null  
    cr = cr.next  
  }  
  // 1. null  
  // 2. 1 -> null  
  // 3. 1 -> 1 -> 2 -> null  
  return result  
}  
```