---  
share: true  
aliases:  
  - 2024-06-13  
title: 2024-06-13  
URL: https://bagrounds.org/reflections/2024-06-13  
Author: "[[bryan-grounds]]"  
tags:   
---  
[Home](../index.md) > [Reflections](./index.md) | [⏮️](./2024-06-12.md)  
# 2024-06-13  
## 🏋️ Practice  
I want to try something a bit different today.  
Rather than spending 15-90 minutes going deep by planning, implementing, and testing a single problem, I'm going to take a shallow, broad pass by reading and planning several problems.  
I'll try to limit each problem to 2-10 minutes of planning, focusing on identifying the key algorithms, data structures, or insights that will be critical in solving the problem, and that also imply runtime complexity.  
For each problem, I should also rate my confidence in my proposed solution.  
Some problems, I won't know how to do at all.  
Some problems, I'll be confident that I can implement the optimal solution in reasonable time.  
And many will likely fall somewhere in between.  
After briefly reviewing many problems, maybe I'll identify some patterns that can be useful in guiding my continued study and practice.  
It could also be interesting to later return to these plans and practice implementing a solution based on a previously derived plan.  
Separating the steps in time may help me understand how valuable the plans actually are and how easily I can turn my own plan into a working solution.  
  
Here we go.  
  
### [6. Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion)  
> The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)  
> P   A   H   N  
> A P L S I I G  
> Y   I   R  
> And then read line by line: `"PAHNAPLSIIGYIR"`  
> Write the code that will take a string and make this conversion given a number of rows  
  
1. This is not a traditional algorithmic problem.  
2. It's really just about sequencing.  
3. I'll need to fill n rows in the correct sequence, then print the rows with the proper format.  
4. Two approaches could be taken here:  
    1. Compute the indices that should go on each row (this doesn't seem like an obvious calculation)  
    2. Iterate between the N rows in an up and down pattern, filling each one character at a time until we're out of characters.  
5. The second options seems easier to implement quickly.  
6. We could track the direction we're moving between the rows (up or down) and change directions when reaching the top or bottom.  
This will take O(N) time in the size of the input string.  
Filling the arrays and then printing will take an additional O(N) space that wouldn't be necessary if we came up with a computation for the position of each character in the sequence.  
This should be fairly straight-forward to implement. Getting the details with the direction exactly right and avoiding out of bounds and null pointer errors could be a bit fiddly.  
**Planning Time: 6:35**  
  
### [7. Reverse Integer](https://leetcode.com/problems/reverse-integer)  
1. Reversing the digits is easy: toString -> toArray -> Reverse -> join -> parseInt  
2. The trick, however, is in the constraint that we can't store a number that's out of range.  
3. So we'll have to be able to identify when a number would be out of the 32 bit signed range before converting the string of digits back to a number.  
4. Alternatively, they might want us to detect overflow (i.e. we attempt to store a number bigger than can fit in 32 bits and the result is simply the wrong 32 bit number).  
5. If we simply had to detect overflow, we could just convert the reversed number back to a string after parsing the integer and check if it's the same string as before parsing.  
6. If we have to proactively decide if the (reversed) number will be too large before converting it to an integer, we can try several approaches  
    1. How many digits is the biggest (or smallest if negative) number we can fit in 32 bits? If our string is fewer digits, we're fine.  
    2. If our string has the max number of digits we can fit in 32 bits, we can check digit-by digit, from largest to smallest: if our reversed number's ith digit is smaller or equal to the max (min) able to fit in that place, we're fine. As soon as we find a digit that is strictly smaller, the remaining digits don't matter.  
There are log10 digits in a base-10 integer, and the amount of work we're doing is proportional to the number of digits, so:  
Runtime complexity: O(log(N)) in the passed in integer.  
Storing the digits will take O(log(N)) space.  
If the first approach is acceptable (I think we'd have to simulate this overflow effect in JavaScript), this implementation seems pretty easy.  
Implementing the second approach is quite doable, but could get a bit messy in tracking all of the details.  
**Planning Time: 11:44**  
  
### [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water)  
> You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.  
> Find two lines that together with the x-axis form a container, such that the container contains the most water.  
> Return _the maximum amount of water a container can store_.  
> **Notice** that you may not slant the container.  
  
1. We want to find 2 lines that maximize the area of the rectangle formed between them  
2. There's an obvious, brute-force, O(N^2) solution that simply compares every line with every other line and computes the area for each  
3. How can we reduce our search space?  
4. Maybe we can compute a sort of rolling maximum while scanning left to right  
    1. It's never necessary to track a shorter line that comes after a taller line as the starting point  
    2. Since we know how long the width is in advance, we can drop from consideration short starting lines with max values that are smaller than an option we're already tracking  
    3. Maybe we always keep track of the tallest starting and ending lines that we've seen  
  
We can make a single forward pass and filter the list to all candidate starting lines.  
Algorithm: keep all lines that are strictly taller than the previously kept line  
  
We can do the same thing in reverse, keeping for consideration ending lines in increasing height (from end to start)  
  
Then we can compare each start line with each end line.  
  
In the worst case, we have a sort of pyramid where the lines grow to the middle, then shrink to the end  
Then we still have N/2 start lines to compare to N/2 end lines, which is still O(N^2)  
Example:  
values : 1 2 3 3 2 1  
indices: 0 1 2 3 4 5  
In this case, we don't need to make all comparisons, we only need to compare a start line with the furthest end line that is equal or shorter in height.  
So we'd compare the following pairs of indices:  
0,5 = 1 x 5 = 5  
1,4 = 2 x 3 = 6  
1,5 = 1 x 4 = 4 <- didn't need because 0,5 already used 5, thus is taller because it's wider  
2,3 = 3 x 1 = 3  
2,4 = 2 x 2  = 4 <- didn't need because 1,4 already used 4, thus is taller because it's wider  
2,5 = 1 x 3 = 3 <- didn't need because 1,5 already used 5, thus is taller because it's wider  
  
So maybe we can do this:  
1. O(N) scan left to right finding candidate starting positions  
2. O(N) scan right to left finding candidate ending positions  
3. O(N) scan left to right, tracking a rolling max, comparing to the furthest end line that is equal or shorter in height **AND** hasn't already been compared earlier  
  
runtime complexity: O(N)  
space complexity: O(N)  
**Planning Time: 40:52**  
I'm not 100% confident that this is correct, but very close to it.  
I think I could implement this without too much trouble.  
  
### [12. Integer to Roman](https://leetcode.com/problems/integer-to-roman)  
> Seven different symbols represent Roman numerals with the following values:  
  
| Symbol | Value |  
| ------ | ----- |  
| I      | 1     |  
| V      | 5     |  
| X      | 10    |  
| L      | 50    |  
| C      | 100   |  
| D      | 500   |  
| M      | 1000  |  
> Roman numerals are formed by appending the conversions of decimal place values from highest to lowest. Converting a decimal place value into a Roman numeral has the following rules:  
> - If the value does not start with 4 or 9, select the symbol of the maximal value that can be subtracted from the input, append that symbol to the result, subtract its value, and convert the remainder to a Roman numeral.  
> - If the value starts with 4 or 9 use the **subtractive form** representing one symbol subtracted from the following symbol, for example, 4 is 1 (`I`) less than 5 (`V`): `IV` and 9 is 1 (`I`) less than 10 (`X`): `IX`. Only the following subtractive forms are used: 4 (`IV`), 9 (`IX`), 40 (`XL`), 90 (`XC`), 400 (`CD`) and 900 (`CM`).  
> - Only powers of 10 (`I`, `X`, `C`, `M`) can be appended consecutively at most 3 times to represent multiples of 10. You cannot append 5 (`V`), 50 (`L`), or 500 (`D`) multiple times. If you need to append a symbol 4 times use the **subtractive form**.  
> Given an integer, convert it to a Roman numeral.  
  
1. This problem seems amenable to recursion:  
    1. decide the first symbol to use, based on the rules  
    2. subtract the value of that symbol from the input value  
    3. make a recursive call using the remainder of the input  
    4. base cases: 0 (empty string) and any value in a lookup table of numbers to their roman numeral symbols  
Time complexity: roman numerals follow a kind of logarithmic pattern, similar to Arabic numerals, so this feels like O(log(N)) in the number provided for conversion.  
Space complexity is the same, and only needed for storing the output string.  
I'm pretty confident I could code this up without much trouble.  
**Planning Time: 7:56**  
  
### [15. 3Sum](https://leetcode.com/problems/3sum)  
> Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.  
> Notice that the solution set must not contain duplicate triplets.  
  
1. The obvious brute force solution is to assemble all triplets and filter them by which of them sum to 0  
    1. O( N choose 3 ) = something like O( N! * K! * / (N - K)! ) ... roughly exponential, which is unacceptable  
2. I've worked on 2Sum and 3Sum somewhat recently, and recall that there are a couple of tricks:  
    1. For 2Sum O(N * log(N)) time complexity / O(1) extra space complexity:  
        1. sort the input, small to large  
        2. use 2 pointers, starting at either end of the list  
        3. if the sum is too small, increment left pointer  
        4. if the sum is too big, decrement right pointer  
        5. if the sum is equal, add the pair to the result set  
        6. continue as long as the pointers aren't equal  
    2.  Alternatively O(N) time complexity / O(N) extra space complexity:  
        1. O(N) build a hash map from values to (lists of) indices  
        2. O(N) for each value, check for target - value in the hash map, with different index  
3. O(N^2) For 3 Sum, we can  
    1. For each element E, fix 1 pointer at this element  
    2. Apply 2Sum with the target = -E on the remainder  
  
I believe I could implement either of these without too much difficulty.  
I'm not sure I could explain exactly why the 2 pointers method works.  
The hash map approach seems straight-forward to explain.  
**Planning Time: 16:09**  
