---
share: true
aliases:
  - 2024-05-19 | ğŸ•¹ï¸ PID ğŸ«› Pod â• Plus ğŸªâŒ¨ï¸
title: 2024-05-19 | ğŸ•¹ï¸ PID ğŸ«› Pod â• Plus ğŸªâŒ¨ï¸
URL: https://bagrounds.org/reflections/2024-05-19
Author: "[[bryan-grounds]]"
tags:
  - code
---
[Home](../index.md) > [Reflections](./index.md) | [â®ï¸](./2024-05-18.md) [â­ï¸](./2024-05-20.md)  
# 2024-05-19 | ğŸ•¹ï¸ PID ğŸ«› Pod â• Plus ğŸªâŒ¨ï¸  
## ğŸï¸ Pod Racing Continued  
- [Yesterday (2024-05-18 | ğŸ•¹ï¸ PID ğŸ«› Pod ğŸ Racer)](./2024-05-18.md) I tried several iterations on my intuitive algorithm.  
- ğŸ“‰ It seems that every added sophistication reduced overall performance.  
- ğŸ¤” This shouldn't really be surprising.  
- ğŸ§  Optimization is often unintuitive.  
- ğŸ’¡ While I can intuit and implement a strategy, it's hard to improve the overall performance without an explicit objective function.  
- âœ… Tractable optimization problems often take the form: minimize (or maximize) a single value under some constraints.  
- â˜ï¸ Having a single optimization variable is important.  
- ğŸ¤¯ Attempting to optimize multiple values simultaneously is _much_ more difficult.  
- ğŸš« It may be fair to say that it's often intractable or even impossible.  
- ğŸŒ± So when we're tempted to optimize multiple values simultaneously, it can be fruitful to pick the objective we care most about and transform the others into constraints.  
- ğŸ’° For example, if we want to simultaneously minimize the duration and cost of a project, we might instead minimize duration under the constraint that cost stays below some threshold.  
- ğŸ In this case, I think our optimization problem is something like: minimize time to complete the race under the constraint that we pass through every way point in the correct order.  
- â“ This sounds nice. It seems like the most direction expression of our ultimate goal. But how do we solve it?  
- ğŸ”¨ A brute force approach could be to  
- ğŸ—ºï¸ generate all possible strategies to complete the race  
- ğŸ—‘ï¸ delete every strategy that doesn't pass through all the checkpoints in the correct order  
- ğŸ¥‡ pick the remaining strategy with the best time  
- ğŸ˜« This problem seems computationally intractable.  
- â“ What even is a strategy to complete the race?  
- ğŸ›£ï¸ Maybe a strategy is a path around the map.  
- ğŸŒŒ Not only are there a very large number of possible paths, but we'd need to add a constraint that our pod can actually follow the path given the game's physics engine.  
  
- ğŸ’¡ One step we could take toward tractability could be to reduce the vast search space with some simplifying assumptions.  
- âœ¨ Another approach could be to focus on solving a series of local optimization problems rather than a single global optimization problem.  
  
- ğŸ¤– The first intuitive algorithm I implemented is essentially a series of local optimization problems.  
- ğŸ¯ The implicit goals are to get to the next checkpoint as quickly as possible.  
- ğŸ—£ï¸ I say that's the implied goal, rather than an explicit goal, because the explicit strategy is to  
- ğŸ§­ always aim at the next checkpoint  
- ğŸ’¯ maintain 100% throttle reduced proportionally to the difference between our pod's heading and the next checkpoint  
- â±ï¸ So it's not even explicitly optimizing for time to each checkpoint.  
- ğŸ“‰ Expressed as an optimization problem, it would be more accurate to say we're minimizing error in trajectory to the next checkpoint.  
- ğŸ¤· Honestly, I don't think it's technically even an optimization problem.  
- ğŸ‘ We really just have a heuristic: reduce throttle by an arbitrarily chosen factor that's proportional to the error in trajectory to the next checkpoint.  
- ğŸ’ª Despite the lack of rigor, this heuristic performed quite well for a while.  
- ğŸš€ So let's see if we can improve the performance with the use of PID controller.  
  
ğŸ‘¨â€ğŸ’» Let's start by rewriting our sample Python code into TypeScript.  
  
```typescript  
type PIDParams = {  
  kp: number  
  ki: number  
  kd: number  
  measurement: number  
  setpoint: number  
  time: number  
}  
type PIDState = {  
  control: number  
  error: number  
  integral: number  
  time: number  
}  
const pid = ({ kp, ki, kd, measurement, setpoint, time }: PIDParams, s: PIDState): PIDState => {  
  const error = setpoint - measurement  
  const de = error - s.error  
  const dt = time - s.time  
  const p = kp * error  
  const i = s.integral + ki * error * dt  
  const d = kd * de / dt  
  const control = p + i + d  
  return {  
    control,  
    error,  
    integral,  
    time  
  }  
}  
```  
  
- ğŸš€ Now let's apply this function in our ğŸï¸ pod racing game.  
- ğŸ“ Our measurement will be the ğŸ“ angle between our pod's heading and the next ğŸ checkpoint.  
- ğŸ¯ Our setpoint will be 0ï¸âƒ£ zero, implying that we want our ğŸï¸ pod pointed at the next ğŸ checkpoint.  
- ğŸ•¹ï¸ Our control variable will be the desired reduction in â›½ throttle.